#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <conio.h>
#include <graphics.h>
#pragma comment(lib,"winmm.lib")
#define length  1200
#define width 700						//数组中0为通路，1为食物，2为毒草，3为障碍物, 4为地雷,5为蛇自己, 6为传送门, 7为下一个入口；
#define size sizeof(struct snake)
#define Tab    9
#define DEL   8
#define LEFT  75
#define RIGHT 77
#define UP    72
#define DOWN  80
#define ESC   27
#define ENTER 13
#define SPACE 32
#define point 10
#define r 10
#define S(x,y) map[(x-70)/20][(y-70)/20]
#define F(x) x*20+70
#define yuan(x,y) solidcircle(x, y, r)
#define Dyuan(x,y) clearcircle(x, y, r)
#define juxing(x,y) fillrectangle(x-r,y-r,x+r,y+r);
#define Djuxing(x,y) clearrectangle(x-r,y-r,x+r,y+r);
FILE * fp;
IMAGE rank0, pic, MAP, cover, frame, gamechoose, setting, background, background0,background1,snake, snake_, star, star_, barrier, barrier_, barrier1, barrier1_;
IMAGE barrier2, barrier2_, barrier3, barrier3_, body, body_, body1, body1_, body2, body2_, body3, body3_;
IMAGE body0, body0_, body01, body01_, body02, body02_, body03, body03_, stone, stone_, blackhole, blackhole_, boom, boom_, TP, TP_;
IMAGE entry, entry_, power, power1, power2, power3, power4, power5, power6, power7, power_, money, coverpart, coverpart1,coverpart3, coverpart4;

char map[54][29];
char snakeNUM[5];
char filename[20], real_password[20];
char address[100];
char dat[6] = ".dat";
char txt[6] = ".txt";
struct snake * head, *tail;
struct snake * p1;                       //蛇移动所需指针 
struct snake * p;						//辅助指针
int map_num;
int TIME = 50;
int BGM_judge = 1;
int snake_num = 5;                       //初始化各个量
int food_num = 5;
int poison_num = 10;
int boom_num = 2;
int tpx1, tpx2, tpy1, tpy2, tpx3, tpx4, tpy3, tpy4;
int speed = 3;
int score;									//记录总分数
int key = RIGHT;
int KeepGame;
char s[20];									//将总分数转化成字符串输出
char Speed[10];								//自定义时提供难度设置
char FoodNum[10];
char PoisonNum[10];
char BoomNum[10];

struct snake       //定义蛇结构体
{
	int x;
	int y;
	struct snake * previous;
	struct snake * next;
};

int chengfang(int n, int m)
{
	int i, k;
	k = 1;
	for (i = 0; i < m; i++)
		k *= n;
	return k;
}

void rank(int n[], int m)     //冒泡排序函数 
{
	int k;
	for (int j = m - 1; j > 0; j--)
		for (int i = 0; i < j; i++)
			if (n[i] < n[i + 1])
			{
				k = n[i];
				n[i] = n[i + 1];
				n[i + 1] = k;
			}
}

int CharToInt(char n[])
{
	int num = 0;
	int j;
	int count;
	count = strlen(n);
	if (n[0] == '-')
		for (j = 0;j < count - 1;j++)
			num -= (n[count - j - 1] - '0')* chengfang(10, j);
	else
		for (j = 0;j < count;j++)
			num += (n[count - j - 1] - '0')* chengfang(10, j);
	return num;
}

void paihang(int score)
{
	char n[10][10], m[10][10] = { 0 };    //n用来显示旧的10个记录，m用来输入新的10个记录	
	int count[10];
	int	num[11] = { 0 };
	int i, j, number;
	number = 0;
	FILE* fp;
	fopen_s(&fp, "rank.dat", "r");
	for (i = 0; i < 10; i++)
	{
		fgets(n[i], 10, fp);
		if (n[i][0] == ' ')
			break;
		count[i] = strlen(n[i]) - 1;
		if (n[i][0] == '-')
			for (j = 0;j < count[i] - 1;j++)
				num[i] -= (n[i][count[i] - j - 1] - '0')* chengfang(10, j);
		else
			for (j = 0;j < count[i];j++)
				num[i] += (n[i][count[i] - j - 1] - '0')* chengfang(10, j);
		number++;
	}
	fclose(fp);
	num[number] = score;
	rank(num, number + 1);
	fopen_s(&fp, "rank.dat", "w");
	for (i = 0;i < 10;i++)
	{
		if (i < number + 1)
		{
			sprintf_s(m[i], "%d", num[i]);
			fputs(m[i], fp);
		}
		else
			fputs(" - - -", fp);
		fputc('\n', fp);
	}
	fclose(fp);
}

void clear_poison()
{
	int i, j;
	for (i = 0; i < 53; i++)
		for (j = 0; j < 28; j++)
			if (map[i][j] == 2)
			{
				map[i][j] = 0;
				Dyuan(F(i), F(j));
			}
}

void clear_boom()
{
	int i, j;
	for (i = 0; i < 53; i++)
		for (j = 0; j < 28; j++)
			if (map[i][j] == 4)
			{
				map[i][j] = 0;
				Dyuan(F(i), F(j));
			}
}

void reprint_boom()
{
	int x, y;
	srand(time(0));
	while (1)
	{
		x = (rand() % 52 + 1) * 20 + 70;
		y = (rand() % 27 + 1) * 20 + 70;
		if (S(x, y) == 0)
			break;
	}
	S(x, y) = 4;
	score -= 30;
	setbkmode(TRANSPARENT);
	settextcolor(BLACK);
	putimage(1280, 440, &coverpart3);
	putimage(1260, 0, &coverpart4);
	sprintf_s(snakeNUM, "%d", snake_num);
	outtextxy(1280, 440, snakeNUM);
	outtextxy(1260, 0, "      ");
	sprintf_s(s, "%d", score);
	outtextxy(1260, 0, s);
}

int definition_TP()        //定义传送门
{
	int i, j, judge = 0;
	for(j = 0;j < 28;j++)
		for (i = 0;i < 53;i++)
		{
			if (map[i][j] == 6)
			{
				if (judge == 0)
				{
					tpx1 = F(i); tpy1 = F(j); judge++;
				}
				else if (judge == 1)
				{
					tpx2 = F(i); tpy2 = F(j); judge++;
				}
				else if (judge == 2)
				{
					tpx3 = F(i); tpy3 = F(j); judge++;
				}
				else if (judge == 3)
				{
					tpx4 = F(i); tpy4 = F(j); judge++;
				}
			}if (judge == 4)
				return 0;
		}
}

void snake_TP()
{
	if (head->x == tpx1 && head->y == tpy1)
	{
		head->x = tpx2; 
		head->y = tpy2;
	}
	else if(head->x == tpx2 && head->y == tpy2)
	{
		head->x = tpx1;
		head->y = tpy1;
	}
	else if (head->x == tpx3 && head->y == tpy3)
	{
		head->x = tpx4;
		head->y = tpy4;
	}
	else
	{
		head->x = tpx3;
		head->y = tpy3;
	}
}

void definition_boom()       //定义地雷
{
	int i, x, y;
	srand(time(0));
	for (i = 0;i < boom_num;i++)
	{
		while (1)
		{
			x = (rand() % 52 + 1) * 20 + 70;
			y = (rand() % 27 + 1) * 20 + 70;
			if (S(x, y) == 0)
				break;
		}
		S(x, y) = 4;
	}
}

void print_poison()
{
	int i, j;
	setfillcolor(RED);
	for (i = 0; i < length / (2 * r) - 1; i++)
		for (j = 0; j < width / (2 * r) - 1; j++)
			if (map[i][j] == 2)
				yuan(F(i), F(j));
}

void reprint_poison()
{
	int x, y;
	srand(time(0));
	while (1)
	{
		x = (rand() % 52 + 1) * 20 + 70;
		y = (rand() % 27 + 1) * 20 + 70;
		if (S(x, y) == 0)
			break;
	}
	S(x, y) = 2;
	score -= 10;
	setbkmode(TRANSPARENT);
	settextcolor(BLACK);
	putimage(1280, 440, &coverpart3);
	putimage(1260, 0, &coverpart4);
	sprintf_s(snakeNUM, "%d", snake_num);
	outtextxy(1280, 440, snakeNUM);
	outtextxy(1260, 0, "      ");
	sprintf_s(s, "%d", score);
	outtextxy(1260, 0, s);
}

void delete_poison()
{
	int i, j;
	for (i = 0; i < length / (2 * r) - 1; i++)
		for (j = 0; j < width / (2 * r) - 1; j++)
			if (map[i][j] == 2)
				Dyuan(F(i), F(j));
}

void definition_poison()       //定义毒草
{
	int i, x, y;
	srand(time(0));
	for (i = 0;i < poison_num;i++)
	{
		while (1)
		{
			x = (rand() % 52 + 1) * 20 + 70;
			y = (rand() % 27 + 1) * 20 + 70;
			if (S(x, y) == 0)
				break;
		}
		S(x, y) = 2;
	}
}

void print_snake()
{
	p1 = head->previous;
	setfillcolor(BLACK);
	for (int i = 0; i < snake_num - 1; i++)
	{
		if (i == snake_num - 2)
			if (p1->x != (p1->next)->x)
				if (p1->x > (p1->next)->x)
				{
					putimage(p1->x - 25, p1->y - 25, &body_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body, SRCPAINT);
				}
				else
				{
					putimage(p1->x - 25, p1->y - 25, &body2_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body2, SRCPAINT);
				}
			else
				if (p1->y > (p1->next)->y)
				{
					putimage(p1->x - 25, p1->y - 25, &body3_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body3, SRCPAINT);
				}
				else
				{
					putimage(p1->x - 25, p1->y - 25, &body1_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body1, SRCPAINT);
				}
		else
			if (p1->x != (p1->next)->x)
				if (p1->x > (p1->next)->x)
				{
					putimage(p1->x - 25, p1->y - 25, &body0_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body0, SRCPAINT);
				}
				else
				{
					putimage(p1->x - 25, p1->y - 25, &body02_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body02, SRCPAINT);
				}
			else
				if (p1->y > (p1->next)->y)
				{
					putimage(p1->x - 25, p1->y - 25, &body03_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body03, SRCPAINT);
				}
				else
				{
					putimage(p1->x - 25, p1->y - 25, &body01_, SRCAND);
					putimage(p1->x - 25, p1->y - 25, &body01, SRCPAINT);
				}
		S(p1->x, p1->y) = 5;
		p1 = p1->previous;
	}
	putimage(head->x - 15, head->y - 15, &snake_, SRCAND);
	putimage(head->x - 15, head->y - 15, &snake, SRCPAINT);

}

void boombody()
{
	int i, p;
	p = snake_num;
	snake_num /= 2;

	for (i = 0; i < p - snake_num; i++)
	{
		p1 = tail;
		tail = tail->next;
		Dyuan(p1->x, p1->y);
		S(p1->x, p1->y) = 0;
		free(p1);
	}
}

void deletebody()
{
	p1 = tail;
	tail = tail->next;
	Dyuan(p1->x, p1->y);
	S(p1->x, p1->y) = 0;
	free(p1);
	snake_num--;
}

void createbody(int x, int y)
{
	p = (struct snake *) malloc(size);
	p->next = tail;
	tail->previous = p;
	tail = p;
	tail->x = x;
	tail->y = y;
	snake_num++;
}

void reprint_food()
{
	int x, y;
	srand(time(0));
	while (1)
	{
		x = (rand() % 52 + 1) * 20 + 70;
		y = (rand() % 27 + 1) * 20 + 70;
		if (S(x, y) == 0)
			break;
	}
	S(x, y) = 1;
	score += 5;
	setbkmode(TRANSPARENT);
	settextcolor(BLACK);
	putimage(1280, 440, &coverpart3);
	putimage(1260, 0, &coverpart4);
	sprintf_s(snakeNUM, "%d", snake_num);
	outtextxy(1280, 440, snakeNUM);
	outtextxy(1260, 0, "      ");
	sprintf_s(s, "%d", score);
	outtextxy(1260, 0, s);
}

void definition_food()       //定义食物
{
	int i, x, y;
	srand(time(0));
	for (i = 0;i < food_num;i++)
	{
		while (1)
		{
			x = (rand() % 52 + 1) * 20 + 70;
			y = (rand() % 27 + 1) * 20 + 70;
			if (S(x, y) == 0)
				break;
		}
		S(x, y) = 1;
	}
}

void definition_snake()       //定义蛇链表 
{
	int i;
	p = tail = head = (struct snake *) malloc(size);

	head->x = 510;
	head->y = 310;
	S(head->x, head->y) = 5;
	for (i = 1; i < snake_num; i++)
	{
		head = (struct snake *) malloc(size);
		p->next = head;
		head->previous = p;
		head->next = NULL;
		p = head;
		head->x = 510 + r * 2 * i;
		head->y = 310;
		S(head->x, head->y) = 5;
	}
	setfillcolor(BLACK);
	setlinecolor(WHITE);
}

void graph()   //地图初始化
{
	int i, j;
	setbkmode(TRANSPARENT);
	score = 0;
	for (i = 0; i < 54; i++)
		for (j = 0; j < 29; j++)
			map[i][j] = 3;
	for (i = 1; i < 53; i++)
		for (j = 1; j < 28; j++)
			map[i][j] = 0;
	char sign;
	if (KeepGame == 0)
	{
		switch (map_num)
		{
		case 0:	fopen_s(&fp, "map\\map0.dat", "r");break;
		case 1:	fopen_s(&fp, "map\\map1.dat", "r");break;
		case 2: fopen_s(&fp, "map\\map2.dat", "r");break;
		case 3: fopen_s(&fp, "map\\map3.dat", "r");break;
		case 4:	fopen_s(&fp, "map\\map4.dat", "r");break;
		case 5:	fopen_s(&fp, "map\\map5.dat", "r");break;
		case 6:	fopen_s(&fp, "map\\map6.dat", "r");break;
		case 7:	fopen_s(&fp, "map\\map7.dat", "r");break;
		case 8:	fopen_s(&fp, "map\\map8.dat", "r");break;
		case 9:	fopen_s(&fp, "map\\map9.dat", "r");break;
		case 10:fopen_s(&fp, "map\\map10.dat", "r");break;
		case 11:fopen_s(&fp, "map\\map11.dat", "r");break;
		}
	}
	for (int i = 1; i < 53; i++)
		for (int j = 1; j < 28; j++)
		{
			sign = fgetc(fp) - '0';
			map[i][j] = sign;
		}
	if (KeepGame == 1)
	{
		fgetc(fp);
		char n[10] = { 0 };
		fgets(n, 5, fp);
		n[strlen(n) - 1] = 0;
		snake_num = CharToInt(n);
	}
	definition_snake();
	if (KeepGame == 0)
	{
			if (map_num > 0)
				definition_food();
			if (map_num > 1)
				definition_poison();
			if (map_num > 2)
				definition_boom();
			if (map_num > 3)
				definition_TP();
	}
	fclose(fp);
	KeepGame = 0;
	putimage(0, 0, &background);
	getimage(&background0, 0, 0, 1200, 700);
	getimage(&background1, 0, 0, 1200, 400);
	settextstyle(32, 0, _T("微软雅黑"));
	settextcolor(BLACK);
	outtextxy(1200, 0, "分数:");
	outtextxy(1200, 100, "游戏规则:");
	settextstyle(25, 0, _T("微软雅黑"));
	outtextxy(1200, 140, "方向键控制星星移动");
	outtextxy(1200, 180, "ESC 暂停");
	outtextxy(1200, 220, "碰到障碍物或碰到自己");
	outtextxy(1200, 260, "死亡");
	settextstyle(32, 0, _T("微软雅黑"));
	setfillcolor(BLUE);
	outtextxy(1300, 440, " /24 ");
	sprintf_s(s, "%d", score);
	getimage(&coverpart3, 1280, 440, 100, 40);
	getimage(&coverpart4, 1260, 0, 100, 40);
	sprintf_s(snakeNUM, "%d", snake_num);
	outtextxy(1280, 440, snakeNUM);
	outtextxy(1260, 0, s);
}

void print()
{
	int i, j;
	static int count = 0;
	count++;
	putimage(0, 0, &background0);
	for (i = 0;i < 7;i++)
	{
		if (i % 2 == 0)
		{
			putimage(i * 170, 0, &barrier_, SRCAND);
			putimage(i * 170, 0, &barrier, SRCPAINT);
			putimage(i * 170, 600, &barrier_, SRCAND);
			putimage(i * 170, 600, &barrier, SRCPAINT);
		}
		else
		{
			putimage(i * 170, 0, &barrier1_, SRCAND);
			putimage(i * 170, 0, &barrier1, SRCPAINT);
			putimage(i * 170, 600, &barrier_, SRCAND);
			putimage(i * 170, 600, &barrier, SRCPAINT);
		}
	}
	for (i = 0;i < 4;i++)
	{
		if (i % 2 == 0)
		{
			putimage(0, i * 170, &barrier2_, SRCAND);
			putimage(0, i * 170, &barrier2, SRCPAINT);
			putimage(1100, i * 170, &barrier2_, SRCAND);
			putimage(1100, i * 170, &barrier2, SRCPAINT);
		}
		else
		{
			putimage(0, i * 170, &barrier3_, SRCAND);
			putimage(0, i * 170, &barrier3, SRCPAINT);
			putimage(1100, i * 170, &barrier3_, SRCAND);
			putimage(1100, i * 170, &barrier3, SRCPAINT);
		}
	}
	for (i = 1; i < 53; i++)
		for (j = 1; j < 28; j++)
			switch (map[i][j])
			{
			case 0:break;
			case 1: putimage(F(i) - 15, F(j) - 15, &star_, SRCAND); putimage(F(i) - 15, F(j) - 15, &star, SRCPAINT);break;
			case 2: if (count <= 5)
			{
				putimage(F(i) - 15, F(j) - 15, &blackhole_, SRCAND); putimage(F(i) - 15, F(j) - 15, &blackhole, SRCPAINT);
			}break;
			case 3: putimage(F(i) - 15, F(j) - 15, &stone_, SRCAND); putimage(F(i) - 15, F(j) - 15, &stone, SRCPAINT);break;
			case 4: putimage(F(i) - 20, F(j) - 20, &boom_, SRCAND); putimage(F(i) - 20, F(j) - 20, &boom, SRCPAINT);break;
			case 6: putimage(F(i) - 15, F(j) - 15, &TP_, SRCAND); putimage(F(i) - 15, F(j) - 15, &TP, SRCPAINT);break;
			case 7: if (j != 16) break;
					putimage(F(i), F(j)-40, &entry_, SRCAND); putimage(F(i), F(j)-40, &entry, SRCPAINT);
			}
	if (count == 10)
		count = 0;
}

void load_address(char name[], int m, char type[])
{
	int i, i0, j, k = 0, t = 0, s;
	s = i0 = i = strlen("client\\");
	sprintf_s(address, "%s", "client\\");
	for (s;s < 100;s++)
		address[s] = 0;
	j = strlen(name);
	for (i;i < (i0 + j + 4);i++)
	{
		if (i >= i0 + j)
		{
			address[i] = type[t];
			t++;
		}
		else
		{
			address[i] = name[k];
			k++;
		}
	}
}

void preparation()
{
	settextcolor(WHITE);
	settextstyle(256, 0, _T("微软雅黑"));
	setbkmode(OPAQUE);
	outtextxy(600, 0, "3");
	Sleep(500);
	outtextxy(600, 0, "2");
	Sleep(500);
	outtextxy(600, 0, "1");
	Sleep(500);
	settextstyle(32, 0, _T("微软雅黑"));
}

void JUDGE()
{
	if (snake_num >= 21)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power, SRCPAINT);
	}
	if (snake_num >= 18 && snake_num <= 20)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power1, SRCPAINT);
	}
	if (snake_num >= 15 && snake_num <= 17)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power2, SRCPAINT);
	}
	if (snake_num >= 12 && snake_num <= 14)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power3, SRCPAINT);
	}
	if (snake_num >= 9 && snake_num <= 11)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power4, SRCPAINT);
	}
	if (snake_num >= 6 && snake_num <= 8)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power5, SRCPAINT);
	}
	if (snake_num >= 3 && snake_num <= 5)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power6, SRCPAINT);
	}
	if (snake_num >= 1 && snake_num <= 2)
	{
		putimage(1200, 450, &power_, SRCAND); putimage(1200, 450, &power7, SRCPAINT);
	}
	if (map_num == 0)
		 map[52][15] = map[52][16] = map[52][17] = map[52][18] = map[52][19] = 7;
	if(map_num>0 && map_num<11)
		if(snake_num >=24)
			map[52][15] = map[52][16] = map[52][17] = map[52][18] = map[52][19] = 7;
}

void hint()
{
	settextcolor(WHITE);
	settextstyle(32, 0, _T("微软雅黑"));
	setbkmode(TRANSPARENT);
	switch (map_num)
	{
	case 0:putimage(450, 200, &gamechoose);
		outtextxy(450, 230, "欢迎来到游戏，请方向键控制星星移");
		outtextxy(450, 260, "动，注意不要撞到自己的尾焰以及");
		outtextxy(450, 290, "障碍物呀！现在控制星星进入下");
		outtextxy(450, 320, "一关吧！注意ESC可以暂停哟！");
		_getch();break;
	case 1:putimage(450, 200, &gamechoose);
		outtextxy(450, 230, "星星需要搜集星光让自己变得更");
		outtextxy(450, 260, "有力量哟！当星星搜集的星光装满");
		outtextxy(450, 290, "星愿瓶，下一关的传送门就会开启！");
		outtextxy(450, 320, "搜集一份星光可以+5分。");
		_getch();break;
	case 2:putimage(450, 200, &gamechoose);
		outtextxy(450, 230, "小心黑洞！黑洞会吞噬星星的星光");
		outtextxy(450, 260, "当星星的星光被吞噬殆尽时就输了！");
		outtextxy(450, 290, "黑洞会不断地闪烁并每隔一段时间就");
		outtextxy(450, 320, "重新刷新！触碰黑洞会-10分。");
		_getch();break;
	case 3:putimage(450, 200, &gamechoose);
		outtextxy(450, 230, "爆炸星星更可怕！它会炸掉你一半的");
		outtextxy(450, 260, "星光！同时会-30分！庆幸的是爆炸");
		outtextxy(450, 290, "星星不会一直出现，只会出现一段");
		outtextxy(450, 320, "时间然后消失掉。");
		_getch();break;
	case 4:putimage(450, 200, &gamechoose);
		outtextxy(450, 230, "传送门出现了！它可以将星星");
		outtextxy(450, 260, "传送到另一扇传送门的位置，因此");
		outtextxy(450, 290, "星星可以到另一片区域去搜集");
		outtextxy(450, 320, "星光！");
		_getch();break;
	case 5:putimage(450, 200, &gamechoose);
		outtextxy(450, 290, "现在，开始你的旅途吧！！！");
		_getch();break;
	case 10:putimage(450, 200, &gamechoose);
		outtextxy(450, 290, "加油，这是最后一关！！！");
		_getch();break;
}
	putimage(0, 0, &background0);
	print();
	print_snake();
}

int move()                //让蛇移动 
{
	int judge;
	int i, x, y;
	int end = 0;
	int count = 0;
	int boom = 0;
	hint();
	preparation();
	BeginBatchDraw();
	while (1)
	{
		if (_kbhit() == 1)
		{
			judge = _getch();
			if (judge == 224)
				switch (judge = _getch())
				{
				case UP:if (key != DOWN)
					key = judge;
					break;
				case RIGHT:if (key != LEFT)
					key = judge;
					break;
				case DOWN:if (key != UP)
					key = judge;
					break;
				case LEFT:if (key != RIGHT)
					key = judge;
					break;
				}
			if(judge == 27)
			{
				EndBatchDraw();
				settextcolor(WHITE);
				settextstyle(32, 0, _T("微软雅黑"));
				int line = 480, n;
				putimage(450, 200, &gamechoose);
				outtextxy(580, 280, "游戏已暂停");
				outtextxy(480, 400, "继续游戏");
				outtextxy(660, 400, "返回界面并保存");
				while (1)
				{
					settextcolor(WHITE);
					n = _getch();
					if (n == ESC)
						break;
					if (n == ENTER)
						if (line == 480)
							break;
						else
						{
							int  j, k;
							char sign;
							char num[5] = { 0 };
							load_address(filename, 20, txt);
							fopen_s(&fp, address, "w");
							for (j = 1; j < 53; j++)
								for (k = 1; k < 28; k++)
								{
									sign = map[j][k] + '0';
									fputc(sign, fp);
								}
							fputc('\n', fp); sprintf_s(num, "%d", snake_num); fputs(num, fp);
							for (j = 0;j < snake_num;j++)
							{
								fputc('\n', fp);
								sprintf_s(num, "%d", head->x); fputs(num, fp);
								fputc('\n', fp);
								sprintf_s(num, "%d", head->y); fputs(num, fp);
								head = head->previous;
							}
							fputc('\n', fp); fputc(key, fp);
							fputc('\n', fp); sign = map_num; fputc(sign, fp);
							fclose(fp);
							p1 = tail;
							while (tail != NULL)
							{
								tail = tail->next;
								free(p1);
								p1 = tail;
							}
							return 0;
						}
					if (n == 224)
					{
						n = _getch();
						if (n == RIGHT || n == LEFT)
							if (line == 480)
								line = 680;
							else
								line = 480;
					}
					outtextxy(480, 400, "继续游戏");
					outtextxy(660, 400, "返回界面并保存");
					settextcolor(RED);
					if (line == 480)
						outtextxy(480, 400, "继续游戏");
					else
						outtextxy(660, 400, "返回界面并保存");
				}
				print();
				print_snake();
				preparation();
				BeginBatchDraw();
			}
		}
		if (map_num > 1)
		{
			count++;
			if (count == 80)
			{
				clear_poison();
				definition_poison();
				count = 0;
			}
		}
		if (map_num > 2)
		{
			boom++;
			if (boom == 100)
				clear_boom();
			if (boom == 200)
			{
				definition_boom();
				boom = 0;
			}
		}
		p1 = tail;
		x = p1->x;
		y = p1->y;
		for (i = 0; i < snake_num - 1; i++)
		{
			p1->x = (p1->next)->x;
			p1->y = (p1->next)->y;
			p1 = p1->next;
		}
		switch (key)
		{
		case RIGHT:
			head->x += r * 2;
			break;
		case UP:
			head->y -= r * 2;
			break;
		case LEFT:
			head->x -= r * 2;
			break;
		case DOWN:
			head->y += r * 2;
			break;
		}
		switch (S(head->x, head->y))
		{
		case 1:
			createbody(x, y);
			reprint_food();
			break;
		case 2:

			if (snake_num == 1)
				end = 1;
			else
			{
				deletebody();
				reprint_poison();
			}break;
		case 4:
			if (snake_num == 1)
				end = 1;
			else
			{
				boombody();
				reprint_boom();
			}
		case 0: break;
		case 5: end = 1;break;
		case 6: snake_TP();break;
		case 3: end = 1;break;
		case 7:
			if (map_num == 10)
			{
				EndBatchDraw();
				putimage(450, 200, &gamechoose);
				outtextxy(450, 230, "恭喜你！！！！！！");
				outtextxy(450, 260, "你竟然完成了这么高难度的游戏！！");
				outtextxy(450, 290, "现在你可以向游戏制作者炫耀了");
				outtextxy(450, 320, "因为他没有通关。。。。");
				_getch();
				return 0;
			}
			if (map_num < 10)
			{
				map_num++; int sign;
				load_address(filename, 20, dat);
				fopen_s(&fp, address, "r");
				fseek(fp, strlen(real_password) + 2, 0);
				sign = fgetc(fp);
				fclose(fp);
				fopen_s(&fp, address, "w");
				fputs(real_password, fp);
				fputc('\n', fp);
				if (map_num > sign)
					fputc(map_num, fp);
				else
					fputc(sign, fp);
				fclose(fp);
				EndBatchDraw();
				return 1;
			}
		}
		if (end == 1)
			break;
		S(x, y) = 0;
		S(head->x, head->y) = 5;
		S(tpx1, tpy1) = S(tpx2, tpy2) = S(tpx3, tpy3) = S(tpx4,tpy4) = 6;
		print();
		print_snake();
		JUDGE();
		FlushBatchDraw();
		Sleep(TIME);
	}
	p1 = tail;
	while (tail != NULL)
	{
		tail = tail->next;
		free(p1);
		p1 = tail;
	}
	EndBatchDraw();
	putimage(250, 150, &pic);
	setbkmode(TRANSPARENT);
	settextcolor(WHITE);
	settextstyle(128, 0, _T("微软雅黑"));
	outtextxy(450, 200, "你输了！");
	settextstyle(50, 0, _T("微软雅黑"));
	outtextxy(450, 400, "你的分数：");
	outtextxy(650, 400, s);
	outtextxy(350, 550, "重新游戏");
	outtextxy(660, 550, "返回主界面");
	settextstyle(50, 0, _T("微软雅黑"));
	paihang(score);

	int line = 350;
	while (1)
	{
		judge = _getch();
		settextcolor(WHITE);
		outtextxy(350, 550, "重新游戏");
		outtextxy(660, 550, "返回主界面");
		if (judge == 224)
		{
			judge = _getch();
			if (judge == RIGHT || judge == LEFT)
				if (line == 350)
				{
					line = 650;
					settextcolor(RED);
					outtextxy(660, 550, "返回主界面");
				}
				else
				{
					line = 350;
					settextcolor(RED);
					outtextxy(350, 550, "重新游戏");
				}
		}
		if (judge == ENTER)
		{
			if (line == 350)
				return 1;
			else
			{
				load_address(filename,20, txt);
				tpx1 = tpy1 = tpx2 = tpy2 = tpx3 = tpy3 = tpx4 = tpy4 = 0;
				remove(address);
				return 0;
			}
		}
	}
}

int build_barrier()
{
	int x = 510;
	int y = 310;
	int judge;
	int i, j;
	for (i = 0; i < 54; i++)
		for (j = 0; j < 29; j++)
			map[i][j] = 3;
	for (i = 1; i < 53; i++)
		for (j = 1; j < 28; j++)
			map[i][j] = 0;
	putimage(0, 0, &background);
	settextstyle(32, 0, _T("微软雅黑"));
	settextcolor(WHITE);
	putimage(450, 200, &gamechoose);
	outtextxy(450, 230, "方向键控制星星");
	outtextxy(450, 260, "空格键设置障碍，再按消去");
	outtextxy(450, 290, "回车键确认，ESC退出");
	_getch();
	BeginBatchDraw();
	while (1)
	{
		putimage(0, 0, &background);
		print();
		putimage(x-15, y-15, &snake_, SRCAND);
		putimage(x-15, y-15, &snake, SRCPAINT);
		FlushBatchDraw();
		judge = _getch();
		if (judge == SPACE)
			if (S(x, y) == 0)
			{
				S(x, y) = 3;
				putimage(x-15, y - 15, &stone_, SRCAND);
				putimage(x - 15, y - 15, &stone, SRCPAINT);
			}
			else
			{
				S(x, y) = 0;
				Djuxing(x, y);
			}
		if (judge == ENTER)
			break;
		if (judge == ESC)
		{
			EndBatchDraw();
			return 0;
		}
		if (judge == 224)
		{
			Dyuan(x, y);
			switch (judge = _getch())
			{
			case UP: if (y != 90) y -= r * 2;
				break;
			case RIGHT:if (x != 1110) x += r * 2;
				break;
			case DOWN:if (y != 610) y += r * 2;
				break;
			case LEFT: if (x != 90)x -= r * 2;
				break;
			}
		}
	}
	char sign;
	fopen_s(&fp, "map\\map11.dat", "w");
	for (int i = 1; i < 53; i++)
		for (int j = 1; j < 28; j++)
		{
			sign = map[i][j] + '0';
			fputc(sign, fp);
		}
	fclose(fp);
	map_num = 11;
	EndBatchDraw();
	return 1;
}

int game_start()
{
	int i;
	key = RIGHT;
	snake_num = 5;
	graph();
	print();
	print_snake();
	i = move();
	return i;
}

int mainmenu()
{
	int judge, high, enter;
	high = 30;
	enter = 0;
	putimage(0, 0, &cover);
	putimage(10, 10, &frame);
	putimage(10, 110, &frame);
	putimage(10, 210, &frame);
	putimage(10, 310, &frame);
	setbkcolor(BLACK);
	settextcolor(WHITE);
	settextstyle(32, 0, _T("微软雅黑"));
	outtextxy(60, 30, _T("新建用户"));
	outtextxy(60, 130, _T("用户登录"));
	outtextxy(60, 230, _T("排行榜"));
	outtextxy(60, 330, _T("退出游戏"));
	while (1)
	{
		judge = _getch();
		if (judge == 224)
		{
			judge = _getch();
			if (judge == UP)
				if (high == 30)
					high = 330;
				else
					high -= 100;
			if (judge == DOWN)
				if (high == 330)
					high = 30;
				else
					high += 100;
			settextcolor(WHITE);
			outtextxy(60, 30, _T("新建用户"));
			outtextxy(60, 130, _T("用户登录"));
			outtextxy(60, 230, _T("排行榜"));
			outtextxy(60, 330, _T("退出游戏"));
			switch (high)
			{
			case 30: settextcolor(RED); outtextxy(60, 30, _T("新建用户")); break;
			case 130:settextcolor(RED); outtextxy(60, 130, _T("用户登录")); break;
			case 230:settextcolor(RED); outtextxy(60, 230, _T("排行榜")); break;
			case 330:settextcolor(RED); outtextxy(60, 330, _T("退出游戏")); break;
			}
		}
		if (judge == ENTER)
			switch (high)
			{
			case 30: enter = 1; break;
			case 130: enter = 2; break;
			case 230: enter = 3; break;
			case 330: enter = 4; break;
			}
		if (enter != 0)
			break;
	}
	return enter;
}

void RANK()
{
	int i;
	char score[10], number[5];
	settextcolor(WHITE);
	setbkmode(TRANSPARENT);
	settextstyle(40, 0, _T("微软雅黑"));
	putimage(500, 50, &rank0);
	fopen_s(&fp, "rank.dat", "r");
	for (i = 0;i < 10;i++)
	{
		sprintf_s(number, "%d.", i + 1);
		outtextxy(500, 70 + i * 45, number);
		fgets(score, 10, fp);
		outtextxy(540, 70 + i * 45, score);
	}
	settextstyle(50, 0, _T("微软雅黑"));
	fclose(fp);
	outtextxy(660, 550, "确定");
	i = _getch();
	while (i != ENTER && i != ESC)
		i = _getch();
}

void set()
{
	int high = 70;
	int judge, end;
	static int number = 10;
	end = 0;
	setbkmode(OPAQUE);
	putimage(500, 50, &setting);
	settextcolor(WHITE);
	settextstyle(40, 0, _T("微软雅黑"));
	outtextxy(500, 130, "背景音乐");
	if (BGM_judge == 1)
		outtextxy(800, 130, "开");
	else
		outtextxy(800, 130, "关");
	sprintf_s(FoodNum, "%d", food_num);
	sprintf_s(PoisonNum, "%d", poison_num);
	sprintf_s(BoomNum, "%d", boom_num);
	sprintf_s(Speed, "%d", speed);
	outtextxy(500, 190, "移动速度"); outtextxy(800, 190, Speed);
	outtextxy(500, 250, "黑洞数量"); outtextxy(800, 250, PoisonNum);
	outtextxy(500, 310, "爆炸星数量"); outtextxy(800, 310, BoomNum);
	outtextxy(500, 370, "星光数量"); outtextxy(800, 370, FoodNum);
	outtextxy(660, 430, "确定");
	getimage(&coverpart, 900, 0, 500, 700);
	while (1)
	{
		judge = _getch();
		if (judge == ESC)
			break;
		if (judge == 224)
		{
			judge = _getch();
			if (judge == UP)
				if (high != 70)
					high -= 60;
			if (judge == DOWN)
				if (high != 430)
					high += 60;
			settextcolor(WHITE);
			settextstyle(40, 0, _T("微软雅黑"));
			outtextxy(500, 130, "背景音乐");
			outtextxy(660, 430, "确定");
			outtextxy(500, 190, "移动速度"); outtextxy(800, 190, Speed);
			outtextxy(500, 250, "黑洞数量"); outtextxy(800, 250, PoisonNum);
			outtextxy(500, 310, "爆炸星数量"); outtextxy(800, 310, BoomNum);
			outtextxy(500, 370, "星光数量"); outtextxy(800, 370, FoodNum);
			switch (high)
			{
			case 130: settextcolor(RED); outtextxy(500, 130, "背景音乐"); break;
			case 190:settextcolor(RED); outtextxy(500, 190, "移动速度"); break;
			case 250:settextcolor(RED); outtextxy(500, 250, "黑洞数量"); break;
			case 310:settextcolor(RED); outtextxy(500, 310, "爆炸星数量"); break;
			case 370:settextcolor(RED); outtextxy(500, 370, "星光数量"); break;
			case 430:settextcolor(RED); outtextxy(660, 430, "确定"); break;
			}
		}
		if (judge == ENTER)
			switch (high)
			{
			case 130: settextcolor(WHITE);
				if (BGM_judge == 1)
				{
					BGM_judge = 0;
					outtextxy(800, 130, "关");
					PlaySound(NULL, NULL, SND_FILENAME);
				}
				else
				{
					BGM_judge = 1;
					outtextxy(800, 130, "开");
					PlaySound("music\\1.wav", NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);
				}break;
			case 190: settextcolor(RED); outtextxy(800, 190, Speed);
				while (1)
				{
					judge = _getch();
					if (judge == ESC || judge == ENTER)
					{
						settextcolor(WHITE);
						outtextxy(800, 190, Speed);
						break;
					}
					if (judge == 224)
					{
						judge = _getch();
						if (judge == RIGHT)
							if (speed != 5)
							{
								speed++;
								TIME -= 10;
							}
						if (judge == LEFT)
							if (speed != 1)
							{
								TIME += 10;
								speed--;
							}
						sprintf_s(Speed, "%d", speed);
						outtextxy(800, 190, "    ");
						outtextxy(800, 190, Speed);
					}
				} break;
			case 250: settextcolor(RED); outtextxy(800, 250, PoisonNum);
				while (1)
				{
					judge = _getch();
					if (judge == ESC || judge == ENTER)
					{
						settextcolor(WHITE);
						outtextxy(800, 250, PoisonNum);
						break;
					}
					if (judge == 224)
					{
						judge = _getch();
						if (judge == RIGHT)
							if (poison_num != 50)
								poison_num++;
						if (judge == LEFT)
							if (poison_num != 5)
								poison_num--;
						sprintf_s(PoisonNum, "%d", poison_num);
						outtextxy(800, 250, "    ");
						outtextxy(800, 250, PoisonNum);
					}
				}break;
			case 310: settextcolor(RED); outtextxy(800, 310, BoomNum);
				while (1)
				{
					judge = _getch();
					if (judge == ESC || judge == ENTER)
					{
						settextcolor(WHITE);
						outtextxy(800, 310, BoomNum);
						break;
					}
					if (judge == 224)
					{
						judge = _getch();
						if (judge == RIGHT)
							if (boom_num != 50)
								boom_num++;
						if (judge == LEFT)
							if (boom_num != 2)
								boom_num--;
						sprintf_s(BoomNum, "%d", boom_num);
						outtextxy(800, 310, "    ");
						outtextxy(800, 310, BoomNum);
					}
				}break;
			case 370: settextcolor(RED); outtextxy(800, 370, FoodNum);
				while (1)
				{
					judge = _getch();
					if (judge == ESC || judge == ENTER)
					{
						settextcolor(WHITE);
						outtextxy(800, 370, FoodNum);
						break;
					}
					if (judge == 224)
					{
						judge = _getch();
						if (judge == RIGHT)
							if (food_num != number)
								food_num++;
							else
							{
								if (number == 10)
								{
									putimage(900, 100, &gamechoose);
									settextcolor(WHITE);
									settextstyle(40, 0, _T("微软雅黑"));
									outtextxy(900, 100, "骚年，渴望有更多星光吗？");
									outtextxy(900, 150, "    你懂的（滑稽）");
									putimage(900, 200, &money);
										while (1)
										{
											judge = _getch();
											if (judge == ESC || judge == ENTER)
											{
												putimage(900, 0, &coverpart);
												settextcolor(RED);
												break;
											}
											if (judge == 's')
												if (judge = _getch() == 'u')
													if (judge = _getch() == 'j')
														if (judge = _getch() == 'i')
															if (judge = _getch() == 'n')
															{
																number = 50;
																break;
															}
										}
								}
							}
						if (judge == LEFT)
							if (food_num != 1)
								food_num--;
						sprintf_s(FoodNum, "%d", food_num);
						outtextxy(800, 370, "    ");
						outtextxy(800, 370, FoodNum);
					}
				}break;
			case 430: end = 1;break;
			}
		if (end == 1)
			break;
	}
}

int choose_map()
{
	int judge, map, i;
	char num[5] = {0};
	getimage(&coverpart1, 900, 0, 400, 500);
	load_address(filename, 20, dat);
	fopen_s(&fp, address, "r");
	fseek(fp,strlen(real_password)+2,0);
	map = fgetc(fp);
	sprintf_s(num, "%d", map);
	settextstyle(30, 0, _T("微软雅黑"));
	settextcolor(WHITE);
	putimage(900, 100, &frame);
	putimage(900, 170, &MAP);
	outtextxy(920, 120, "你最高闯关数：");
	outtextxy(1060, 120, num);
	for (i = 0;i < 11;i++)
	{
		sprintf_s(num, "%d", i); outtextxy(920+i*30, 200, num);
	}
	getimage(&coverpart, 900,170,400,100);
	fclose(fp);
	i = 0;
	settextcolor(RED);
	while (1)
	{
		judge = _getch();
		if (judge == 224)
		{
			judge = _getch();
			if (judge == LEFT && i > 0)
				i--;
			if (judge == RIGHT && i < 10 && i< map)
				i++;
		}
		putimage(900, 170, &coverpart);
		sprintf_s(num, "%d", i); outtextxy(920 + i * 30, 200, num);
		if (judge == ESC)
		{
			putimage(900, 0, &coverpart1);
			settextstyle(40, 0, _T("微软雅黑"));
			return 0;
		}
		if (judge == ENTER)
		{
			map_num = i;
			return 1;
		}
	}
}

int game_choose()
{
	int i, judge;
	int high = 130;
	int end = 0;
	putimage(500, 100, &gamechoose);
	setbkmode(TRANSPARENT);
	settextstyle(40, 0, _T("微软雅黑"));
	settextcolor(WHITE);
	outtextxy(630, 130, "从头开始");
	outtextxy(630, 200, "选择关卡");
	outtextxy(630, 270, "DIY模式");
	outtextxy(660, 340, "返回");
	while (1)
	{
		judge = _getch();
		if (judge == 224)
		{
			judge = _getch();
			if (judge == UP)
				if (high != 130)
					high -= 70;
			if (judge == DOWN)
				if (high != 340)
					high += 70;
			settextcolor(WHITE);
			outtextxy(630, 130, "从头开始");
			outtextxy(630, 200, "选择关卡");
			outtextxy(630, 270, "DIY模式");
			outtextxy(660, 340, "返回");
			switch (high)
			{
			case 130: settextcolor(RED); outtextxy(630, 130, "从头开始"); break;
			case 200:settextcolor(RED); outtextxy(630, 200, "选择关卡"); break;
			case 270:settextcolor(RED); outtextxy(630, 270, "DIY模式"); break;
			case 340:settextcolor(RED); outtextxy(660, 340, "返回"); break;
			}
		}
		if (judge == ENTER)
			switch (high)
			{
			case 130: map_num = 0, key = RIGHT;return 1;
			case 200: if (choose_map() == 1)
				return 1; break;
			case 270: i = build_barrier(); return i;
			case 340: return 0;
			}
		if (judge == ESC)
			return 0;

	}
}

int client()
{
	int i, j;
	j = i = 0;
	char sign = 0;
	char f[20] = { 0 }, p[20] = { 0 }, name[20] = { 0 }, password[20] = { 0 };
	setfillcolor(YELLOW);
	settextcolor(WHITE);
	setbkmode(TRANSPARENT);
	settextstyle(28, 0, _T("微软雅黑"));
	putimage(500, 100, &gamechoose);
	outtextxy(530, 170, "请创建用户名：(1-15位,不区分大小写)");
	outtextxy(500, 200, "Tab键换行");
	fillrectangle(600, 200, 800, 220);
	outtextxy(500, 270, "Tab键换行");
	outtextxy(600, 240, "请输入密码：(1-15位)");
	setfillcolor(WHITE);
	fillrectangle(600, 270, 800, 290);
	outtextxy(670, 320, "确定");
	settextcolor(BLACK);
	while (1)
	{
		setfillcolor(YELLOW);
		fillrectangle(600, 200, 800, 220);
		outtextxy(600, 195, f);
		while (1)
		{
			sign = _getch();
			if (sign == ESC)
				return 0;
			if (sign == -32)
			{
				_getch();continue;
			}
			if (sign == Tab)
				break;
			if (sign == DEL)
			{
				if (j != 0)
					name[--j] = ' ';
				fillrectangle(600, 200, 800, 220);
			}
			else if(sign != ENTER)
				if (j != 15)
					name[j++] = sign;
			sprintf_s(f, "%s", name);
			outtextxy(600, 195, f);
		}
		setfillcolor(WHITE);
		fillrectangle(600, 200, 800, 220);
		outtextxy(600, 195, f);
		setfillcolor(YELLOW);
		fillrectangle(600, 270, 800, 290);
		outtextxy(600, 270, p);
		while (1)
		{

			sign = _getch();
			if (sign == ESC)
				return 0;
			if (sign == -32)
			{
				_getch();continue;
			}
			if (sign == Tab)
				break;
			if (sign == DEL)
			{
				if (i != 0)
				{
					password[--i] = ' ';
					p[i] = ' ';
				}
				fillrectangle(600, 270, 800, 290);
			}
			else if(sign != ENTER)
				if (i != 15)
				{
					password[i] = sign;
					p[i] = '*';
					i++;
				}
			outtextxy(600, 270, p);
		}
		setfillcolor(WHITE);
		fillrectangle(600, 270, 800, 290);
		outtextxy(600, 270, p);
		settextcolor(RED);
		while (1)
		{
			outtextxy(670, 320, "确定");
			sign = _getch();
			if (sign == ESC)
				return 0;
			if (sign == Tab)
				break;
			if (sign == ENTER)
			{
				load_address(name,20,dat);
				if (j == 0)
				{
					settextcolor(RED);
					outtextxy(800, 195, "不能为空");
				}
				else if (i == 0)
				{
					settextcolor(RED);
					outtextxy(800, 265, "不能为空");
				}
				else if (fopen_s(&fp, address, "r") == 0)
				{
					setbkmode(OPAQUE);
					outtextxy(600, 140, "用户名已存在");
					setbkmode(TRANSPARENT);
				}
				else
				{
					setbkmode(OPAQUE);
					settextcolor(WHITE);
					outtextxy(600, 140, "用户创建成功！");
					for (i = 0;i < 20;i++)
						filename[i] = name[i];
					for (i = 0;i < 20;i++)
						real_password[i] = password[i];
					fopen_s(&fp, address, "w");
					fputs(password, fp);
					fputc('\n', fp);
					fputc(0, fp);
					fputc('\n', fp);
					fclose(fp);
					Sleep(2000);
					return 1;
				}
				break;
			}
		}
		settextcolor(WHITE);
		outtextxy(670, 320, "确定");
		settextcolor(BLACK);
	}
}

int KeepOnGame()
{
	int i, j;
	load_address(filename, 20, txt);
	if (fopen_s(&fp, address, "r") != 0)
	{
		putimage(500, 100, &gamechoose);
		setbkmode(TRANSPARENT);
		settextstyle(40, 0, _T("微软雅黑"));
		settextcolor(WHITE);
		outtextxy(570, 200, "没有正在进行的游戏");
		Sleep(1000);
	}
	else
	{
		char n[20] = { 0 };
		KeepGame = 1;
		graph();
		fopen_s(&fp, address, "r");
		fseek(fp, 2 + 52 * 27, 0);
		fgets(n, 10, fp);
		p1 = head;
		for (j = 0;j < snake_num;j++)
		{
			S(p1->x, p1->y) = 0;
			fgets(n, 10, fp); n[strlen(n) - 1] = 0; p1->x = CharToInt(n);
			fgets(n, 10, fp); n[strlen(n) - 1] = 0; p1->y = CharToInt(n);
			p1 = p1->previous;
		}
		key = (int)fgetc(fp);
		fgetc(fp);
		map_num = (int)fgetc(fp);
		fclose(fp);
		print();
		print_snake();
		i = move();
		return i;
	}
}

int client_menu()
{
	int judge, high, enter;
	high = 30;
	enter = 0;
	putimage(0, 0, &cover);
	putimage(10, 10, &frame);
	putimage(10, 110, &frame);
	putimage(10, 210, &frame);
	putimage(10, 310, &frame);
	putimage(10, 410, &frame);
	setbkcolor(BLACK);
	settextcolor(WHITE);
	settextstyle(32, 0, _T("微软雅黑"));
	outtextxy(60, 30, _T("新的游戏"));
	outtextxy(60, 130, _T("继续游戏"));
	outtextxy(60, 230, _T("游戏设置"));
	outtextxy(60, 330, _T("排行榜"));
	outtextxy(60, 430, _T("退出账号"));
	while (1)
	{
		judge = _getch();
		if (judge == 224)
		{
			judge = _getch();
			if (judge == UP)
				if (high == 30)
					high = 430;
				else
					high -= 100;
			if (judge == DOWN)
				if (high == 430)
					high = 30;
				else
					high += 100;
			settextcolor(WHITE);
			outtextxy(60, 30, _T("新的游戏"));
			outtextxy(60, 130, _T("继续游戏"));
			outtextxy(60, 230, _T("游戏设置"));
			outtextxy(60, 330, _T("排行榜"));
			outtextxy(60, 430, _T("退出账号"));
			switch (high)
			{
			case 30: settextcolor(RED); outtextxy(60, 30, _T("新的游戏")); break;
			case 130:settextcolor(RED); outtextxy(60, 130, _T("继续游戏")); break;
			case 230:settextcolor(RED); outtextxy(60, 230, _T("游戏设置")); break;
			case 330:settextcolor(RED); outtextxy(60, 330, _T("排行榜")); break;
			case 430:settextcolor(RED); outtextxy(60, 430, _T("退出账号")); break;
			}
		}
		if (judge == ENTER)
			switch (high)
			{
			case 30: enter = 1; break;
			case 130: enter = 2; break;
			case 230: enter = 3; break;
			case 330: enter = 4; break;
			case 430: enter = 5; break;
			}
		if (enter != 0)
			break;
	}
	return enter;
}

int keepgame()
{
	int i, j, k, judge;
	j = i = judge = 0;
	FILE * fp;
	char sign = 0;
	char f[20] = { 0 }, p[20] = { 0 }, name[20] = { 0 }, password[20] = { 0 };
	setfillcolor(YELLOW);
	settextcolor(WHITE);
	setbkmode(TRANSPARENT);
	settextstyle(28, 0, _T("微软雅黑"));
	putimage(500, 100, &gamechoose);
	outtextxy(600, 170, "请输入用户名：(1-15位)");
	outtextxy(500, 200, "Tab键换行");
	outtextxy(500, 270, "Tab键换行");
	fillrectangle(600, 200, 800, 220);
	outtextxy(600, 240, "请输入密码：(1-15位)");
	setfillcolor(WHITE);
	fillrectangle(600, 270, 800, 290);
	outtextxy(670, 320, "确定");
	settextcolor(BLACK);
	while (1)
	{
		setfillcolor(YELLOW);
		fillrectangle(600, 200, 800, 220);
		sprintf_s(f, "%s", name);
		outtextxy(600, 195, f);
		while (1)
		{
			sign = _getch();
			if (sign == -32)
			{
				_getch();continue;
			}
			if (sign == ESC)
				return 0;
			if (sign == Tab)
				break;
			if (sign == DEL)
			{
				if (j != 0)
					name[--j] = ' ';
				fillrectangle(600, 200, 800, 220);
			}
			else if(sign != ENTER)
				if (j != 15)
					name[j++] = sign;
			sprintf_s(f, "%s", name);
			outtextxy(600, 195, f);
		}
		setfillcolor(WHITE);
		fillrectangle(600, 200, 800, 220);
		outtextxy(600, 195, f);
		setfillcolor(YELLOW);
		fillrectangle(600, 270, 800, 290);
		outtextxy(600, 270, p);
		while (1)
		{

			sign = _getch();
			if (sign == -32)
			{
				_getch();continue;
			}
			if (sign == ESC)
				return 0;
			if (sign == Tab)
				break;
			if (sign == DEL)
			{
				if (i != 0)
				{
					password[--i] = ' ';
					p[i] = ' ';
				}
				fillrectangle(600, 270, 800, 290);
			}
			else if (sign != ENTER)
				if (i != 15)
				{
					password[i] = sign;
					p[i] = '*';
					i++;
				}
			outtextxy(600, 270, p);
		}
		setfillcolor(WHITE);
		fillrectangle(600, 270, 800, 290);
		outtextxy(600, 270, p);
		settextcolor(RED);
		while (1)
		{
			outtextxy(670, 320, "确定");
			sign = _getch();
			if (sign == ESC)
				return 0;
			if (sign == Tab)
				break;
			if (sign == ENTER)
			{
				load_address(name,20,dat);
				if (j == 0)
				{
					settextcolor(RED);
					outtextxy(800, 195, "不能为空");
				}
				else if (i == 0)
				{
					settextcolor(RED);
					outtextxy(800, 265, "不能为空");
				}
				else if (fopen_s(&fp, address, "r") != 0)
				{
					setbkmode(OPAQUE);
					outtextxy(600, 140, "用户名不存在");
					for (k = 0;k < 20;k++)
						name[k] = 0;
					j = 0;
					setbkmode(TRANSPARENT);
				}
				else
				{
					fgets(real_password, 20, fp);
					real_password[strlen(real_password) - 1] = 0;
					fclose(fp); 
					judge = 1;
					for (int t = 0; t < 20; t++)
						if (password[t] != real_password[t])
						{
							setbkmode(OPAQUE);
							outtextxy(600, 140, "密码输入错误");
							for (k = 0;k < 20;k++)
								password[k] = p[k] = 0;
							i = 0;
							fillrectangle(600, 270, 800, 290);
							setbkmode(TRANSPARENT);
							judge = 0;
							break;
						}
				}
				if (judge == 1)
				{
					setbkmode(OPAQUE);
					settextcolor(WHITE);
					outtextxy(600, 140, "用户登录成功！");
					for (i = 0;i < 20;i++)
						filename[i] = name[i];
					Sleep(2000);
					return 1;

				}
				break;
			}
		}
		settextcolor(WHITE);
		outtextxy(670, 320, "确定");
		settextcolor(BLACK);
	}
}

void choose()
{
	int i, j, n, judge, judge0 ;
	while (1)
	{
		judge = 1;
		i = mainmenu();
		switch (i)
		{
		case 1:;
		case 2: if (i == 2 && keepgame() != 0 || i==1 && client() != 0)
			while (1)
		{
			n = client_menu();
			judge0 = 1;
			j = 1;
			switch (n)
			{
			case 2:
				if(KeepOnGame() == 0)
					break;
			case 1:  if(n != 2)
					j = game_choose();
				while (judge0 == 1 && j != 0)
				{ 
					judge0 = game_start();
				} break;
			case 3: set(); break;
			case 4: RANK(); break;
			case 5: judge0 = -1;break;
			}
			if (judge0 == -1)
				break;
		}break;
		case 3: RANK(); break;
		case 4: judge = -1;break;
		}
		if (judge == -1)
			break;
	}
}

void LoadPic()
{
	loadimage(&money, _T("picture\\money.jpg"),300,400);
	loadimage(&rank0, _T("picture\\rank.jpg"), 400, 550);
	loadimage(&pic, _T("picture\\rank.jpg"), 700, 500);
	loadimage(&MAP, _T("picture\\rank.jpg"), 400, 100);
	loadimage(&power, _T("picture\\power.jpg"), 200, 240);
	loadimage(&power_, _T("picture\\power_.jpg"), 200, 240);
	loadimage(&power1, _T("picture\\power1.jpg"), 200, 240);
	loadimage(&power2, _T("picture\\power2.jpg"), 200, 240);
	loadimage(&power3, _T("picture\\power3.jpg"), 200, 240);
	loadimage(&power4, _T("picture\\power4.jpg"), 200, 240);
	loadimage(&power5, _T("picture\\power5.jpg"), 200, 240);
	loadimage(&power6, _T("picture\\power6.jpg"), 200, 240);
	loadimage(&power7, _T("picture\\power7.jpg"), 200, 240);
	loadimage(&background, _T("picture\\background.jpg"), length+200, width);
	loadimage(&gamechoose, _T("picture\\rank.jpg"), 400, 300);
	loadimage(&cover, _T("picture\\cover.jpg"), 1400, width);
	loadimage(&snake, _T("picture\\snake.jpg"), 30, 30);
	loadimage(&frame, _T("picture\\frame.jpg"), 200, 70);
	loadimage(&setting, _T("picture\\rank.jpg"), 400, 430);
	loadimage(&snake_, _T("picture\\snake_.jpg"), 30, 30);
	loadimage(&entry, _T("picture\\enter.jpg"), 60, 120);
	loadimage(&entry_, _T("picture\\enter_.jpg"), 60, 120);
	loadimage(&star, _T("picture\\star.jpg"), 30, 30);
	loadimage(&star_, _T("picture\\star_.jpg"), 30, 30);
	loadimage(&body, _T("picture\\tail.jpg"), 50, 50);
	loadimage(&body_, _T("picture\\tail_.jpg"), 50, 50);
	loadimage(&body1, _T("picture\\tail1.jpg"), 50, 50);
	loadimage(&body1_, _T("picture\\tail1_.jpg"), 50, 50);
	loadimage(&body2, _T("picture\\tail2.jpg"), 50, 50);
	loadimage(&body2_, _T("picture\\tail2_.jpg"), 50, 50);
	loadimage(&body3, _T("picture\\tail3.jpg"), 50, 50);
	loadimage(&body3_, _T("picture\\tail3_.jpg"), 50, 50);
	loadimage(&body0, _T("picture\\tail-.jpg"), 50, 50);
	loadimage(&body0_, _T("picture\\tail-_.jpg"), 50, 50);
	loadimage(&body01, _T("picture\\tail1-.jpg"), 50, 50);
	loadimage(&body01_, _T("picture\\tail1-_.jpg"), 50, 50);
	loadimage(&body02, _T("picture\\tail2-.jpg"), 50, 50);
	loadimage(&body02_, _T("picture\\tail2-_.jpg"), 50, 50);
	loadimage(&body03, _T("picture\\tail3-.jpg"), 50, 50);
	loadimage(&body03_, _T("picture\\tail3-_.jpg"), 50, 50);
	loadimage(&stone, _T("picture\\stone.jpg"), 25, 30);
	loadimage(&stone_, _T("picture\\stone_.jpg"), 25, 30);
	loadimage(&boom, _T("picture\\boom.jpg"), 40, 40);
	loadimage(&boom_, _T("picture\\boom_.jpg"), 40, 40);
	loadimage(&TP, _T("picture\\TP.jpg"), 40, 30);
	loadimage(&TP_, _T("picture\\TP_.jpg"), 40, 30);
	loadimage(&blackhole, _T("picture\\poison.jpg"), 25, 25);
	loadimage(&blackhole_, _T("picture\\poison_.jpg"), 25, 25);
	loadimage(&barrier, _T("picture\\barrier.jpg"), 200, 100);
	loadimage(&barrier_, _T("picture\\barrier_.jpg"), 200, 100);
	loadimage(&barrier1, _T("picture\\barrier1.jpg"), 200, 100);
	loadimage(&barrier1_, _T("picture\\barrier1_.jpg"), 200, 100);
	loadimage(&barrier2, _T("picture\\barrier2.jpg"), 100, 200);
	loadimage(&barrier2_, _T("picture\\barrier2_.jpg"), 100, 200);
	loadimage(&barrier3, _T("picture\\barrier3.jpg"), 100, 200);
	loadimage(&barrier3_, _T("picture\\barrier3_.jpg"), 100, 200);
}


// 主函数
int main()
{
	initgraph(1400, width);
	LoadPic();
	PlaySound("music\\1.wav", NULL, SND_FILENAME | SND_ASYNC | SND_LOOP);
	choose();
	closegraph();
}